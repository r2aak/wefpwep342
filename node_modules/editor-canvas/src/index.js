var { createCanvas, loadImage } = require("canvas");
///// Error log /////
var error = (err) => {
  throw new Error(err);
};

///// Resize Text /////
var resizeText = (ctx, { text, width, font }) => {
  try {
    if (!ctx || !ctx.canvas) return error("resizeText: ctx not defined");
    if (!text) return error("resizeText: text can't be empty");
    if (!width || isNaN(Number(width))) width = ctx.canvas.width;
    else width = Number(width);
    text = text.toString();
    if (!font || isNaN(Number(font))) font = 20;
    else font = Number(font);
    let fontSize = font;
    do {
      ctx.font = `${(fontSize -= 2)}px `;
    } while (ctx.measureText(text).width > width);
    return ctx.font;
  } catch (e) {
    return error(`resizeText:\n ${e}`);
  }
},

  ///// Split Text /////
  splitText = (ctx, { text, width, maxLine }) => {
    try {
      if (!ctx || !ctx.canvas) return error("splitText: ctx not defined");
      if (!text) return error("splitText: text can't be empty");
      if (!width || isNaN(Number(width))) width = ctx.canvas.width;
      else width = Number(width);
      text = text.toString();
      var Width = ctx.measureText(text).width;
      var end = "";
      width = width - 10;
      var newText = text;
      if (Width > width) {
        newText = "";
        var times = Width / width;
        if (!maxLine || isNaN(Number(maxLine))) maxLine = times;
        else maxLine = Number(maxLine);
        var Times = Math.ceil(text.length / times);
        if (maxLine && times > maxLine) {
          times = maxLine;
          end += "â€¦";
        }
        for (let i = 0; i < times; i++) {
          newText += `${text.slice(
            i * Times,
            i == times ? text.length : Times * (i + 1)
          )}\n`;
        }
      }
      return `${newText.endsWith("\n") ? newText.slice(0, -1) : newText}${end}`;
    } catch (e) {
      return error(`splitText:\n ${e}`);
    }
  },

  ///// Draw Center /////
  drawCenter = (ctx, img, x, y, w, h) => {
    try {
      if (!ctx || !ctx.drawImage) return error("drawCenter: ctx not defined");
      if (!img || !isNaN(img)) return error("drawCenter: img not defined");
      var check =
        typeof x == typeof y &&
        typeof w == typeof h &&
        typeof x == typeof h &&
        typeof x == "number";

      if (!check)
        return error("drawCenter: coordinates can't be string or empty");
      if (img) {
        x -= w / 2;
        y -= h / 2;
        ctx.drawImage(img, x, y, w, h);
      }
    } catch (e) {
      return error(`drawCenter:\n ${e}`);
    }
  },

  ///// Draw Circle /////
  drawCircle = async (
    { image, stroke, fill, weight, Canvas } = {
      fill: "BLACK",
      stroke: "BLACK",
      weight: 5
    }
  ) => {
    try {
      stroke = stroke ? stroke.toUpperCase() : null;
      fill = fill ? fill.toUpperCase() : null;
      weight = stroke
        ? weight && !isNaN(Number(weight))
          ? Number(weight)
          : 5
        : null;
      try {
        image = await loadImage(image);
      } catch (e) {
        image = false;
      }
      var canvas = new createCanvas(image ? image.width : 512, image ? image.height : 512),
        ctx = canvas.getContext("2d"),
        x = weight,
        y = x,
        w = canvas.width - weight * 2,
        h = canvas.height - weight * 2;
      ctx.lineWidth = weight;
      ctx.strokeStyle = stroke;
      ctx.fillStyle = fill;
      ctx.beginPath();
      ctx.arc(x + w / 2, y + h / 2, Math.min(w, h) / 2, 0, Math.PI * 2, true);
      if (stroke) ctx.stroke();
      if (fill) ctx.fill();
      ctx.clip();

      if (image) ctx.drawImage(image, x, y, w, h);
      if (Canvas && Canvas.loadImage) return await Canvas.loadImage(canvas.toBuffer());
      return canvas.toBuffer();
    } catch (e) {
      return error(`drawCircle:\n ${e}`);
    }
  },

  ///// Draw Square /////
  drawSquare = async (
    { image, curve, stroke, fill, weight, Canvas } = {
      curve: 15,
      stroke: "BLACK",
      fill: "BLACK",
      weight: 10,
    }
  ) => {
    try {
      curve = curve && !isNaN(Number(curve)) ? Number(curve) : 15;
      weight = stroke
        ? weight && !isNaN(Number(weight))
          ? Number(weight)
          : 5
        : null;
      try {
        image = await loadImage(image);
      } catch (e) {
        image = false;
      }
      var canvas = new createCanvas(image ? image.width : 512, image ? image.height : 512),
        ctx = canvas.getContext("2d"),
        x = weight,
        y = x,
        w = canvas.width - weight * 2,
        h = canvas.height - weight * 2;

      ctx.lineWidth = weight;
      ctx.strokeStyle = stroke ? stroke.toUpperCase() : null;
      ctx.fillStyle = fill ? fill.toUpperCase() : null;

      if (curve > w || curve > h) curve = Math.floor(Math.min(w, h) / 2);

      ctx.beginPath();
      ctx.moveTo(x + curve, y);

      ctx.lineTo(x + w - curve, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + curve);

      ctx.lineTo(x + w, y + h - curve);
      ctx.quadraticCurveTo(x + w, y + h, x + w - curve, y + h);

      ctx.lineTo(x + curve, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - curve);

      ctx.lineTo(x, y + curve);
      ctx.quadraticCurveTo(x, y, x + curve, y);
      if (stroke) ctx.stroke();
      if (fill) ctx.fill();
      ctx.clip();

      if (image) ctx.drawImage(image, x, y, w, h);
      if (Canvas && Canvas.loadImage) return await Canvas.loadImage(canvas.toBuffer());
      return canvas.toBuffer();
    } catch (e) {
      return error(`drawSquare:\n ${e}`);
    }
  },

  ///// Draw Polygone /////
  drawPolygon = async (
    { image, angle, type, stroke, fill, weight, Canvas } = {
      angle: 10,
      type: 1,
      stroke: "BLACK",
      fill: "BLACK",
      weight: 5,
    }
  ) => {
    try {
      try {
        image = await loadImage(image);
      } catch (e) {
        image = false;
      }
      weight = stroke
        ? weight && !isNaN(Number(weight))
          ? Number(weight)
          : 5
        : null;
      angle = angle && !isNaN(Number(angle)) ? Number(angle) : null;
      type = type && !isNaN(Number(type)) ? Number(type) : 1;
      if (!angle || angle < 3 || angle > 20) {
        console.error("Angle must be a number between 3 and 20");
        angle = 10;
      }
      if (type < 1 || type > 3) type = 1;
      var canvas = new createCanvas(image ? image.width : 512, image ? image.height : 512),
        ctx = canvas.getContext("2d"),
        angle = angle,
        width = canvas.width,
        height = canvas.height,
        typeOptions = [
          { x: width / 2, y: 5 },
          { x: (width / 3) * 2, y: 15 },
          { x: width / 3, y: 15 },
        ];
      type = typeOptions[type - 1];
      ctx.lineWidth = weight;
      ctx.strokeStyle = stroke ? stroke.toUpperCase() : null;
      ctx.fillStyle = fill ? fill.toUpperCase() : null;
      ctx.beginPath();
      ctx.moveTo(type.x, type.y + weight);
      for (let i = 0; i < angle + 1; i++) {
        ctx.translate(width / 2, height / 2);
        ctx.rotate(((360 / angle) * Math.PI) / 180);
        ctx.translate(-width / 2, -height / 2);
        ctx.lineTo(type.x, type.y + weight);
      }
      ctx.translate(width / 2, height / 2);
      ctx.rotate(((Math.ceil(angle) + 1) * (-360 / angle) * Math.PI) / 180);
      ctx.translate(-width / 2, -height / 2);
      if (stroke) ctx.stroke();
      if (fill) ctx.fill();
      ctx.clip();

      if (image) {
        ctx.drawImage(
          image,
          weight / 2,
          weight / 2,
          width - weight / 2,
          height - weight / 2
        );
      }
      if (Canvas && Canvas.loadImage) return await Canvas.loadImage(canvas.toBuffer());
      return canvas.toBuffer();
    } catch (e) {
      return error(`drawPolygon:\n ${e}`);
    }
  },

  ///// Resize Image /////
  resizeImage = async ({ image, width, height, Canvas } = {}) => {
    if (!image) throw new Error(`Image can't be not defined`);
    try {
      try {
        image = await loadImage(image);
      } catch (e) {
        image = false;
      }
      if (!image) return error("Invalid image");
      width = !width || isNaN(Number(width)) ? image.width : Number(width);
      height = !height || isNaN(Number(height)) ? image.width : Number(height);
      var canvas = new createCanvas(width, height),
        ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      if (Canvas && Canvas.loadImage) return await Canvas.loadImage(canvas.toBuffer());
      return canvas.toBuffer();
    } catch (e) {
      return error(`resizeImage:\n ${e}`);
    }
  },


  ///// Crop Image /////
  cropImage = async ({ image, x, y, width, height, Canvas } = {}) => {
    if (!image) throw new Error(`Image can't be not defined`);
    try {
      try {
        image = await loadImage(image);
      } catch (e) {
        image = false;
      }
      if (!image) return error("Invalid image");
      if (isNaN(+x) || isNaN(+y) || isNaN(+width) || isNaN(+height)) return error("x, y, width, height must be a number only !");
      /////
      if (+image.width < +width) width = +image.width;
      if (+image.height < +height) height = +image.height;
      if ((+width + +x) > +image.width) width = +image.width - +x;
      if ((+height + +y) > +image.height) height = +image.height - +y;
      /////
      var canvas = createCanvas(+width, +height),
        ctx = canvas.getContext("2d");
      ctx.drawImage(image, +x, +y, +width, +height, 0, 0, +width, +height);
      if (Canvas && Canvas.loadImage) return await Canvas.loadImage(canvas.toBuffer());
      return canvas.toBuffer();
    } catch (e) {
      return error(`cropImage:\n ${e}`);
    }
  };

///// Module(s) /////
module.exports = {
  resizeText, splitText, drawCenter, drawCircle, drawSquare, drawPolygon, resizeImage, cropImage,
}
